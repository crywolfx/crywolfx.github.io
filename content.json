{"meta":{"title":"wxin's blog","subtitle":null,"description":"IT搬运工","author":"Alex Wong","url":"http://crywolfx.github.io"},"pages":[{"title":"categories","date":"2018-10-08T09:01:09.000Z","updated":"2022-07-26T06:26:20.358Z","comments":true,"path":"categories/index.html","permalink":"http://crywolfx.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-10-08T09:01:04.000Z","updated":"2022-07-26T06:26:20.359Z","comments":true,"path":"tags/index.html","permalink":"http://crywolfx.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Hello World","slug":"hello-world","date":"2022-07-26T06:26:20.357Z","updated":"2022-07-26T06:26:20.357Z","comments":true,"path":"2022/07/26/hello-world/","link":"","permalink":"http://crywolfx.github.io/2022/07/26/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"test","slug":"test","permalink":"http://crywolfx.github.io/categories/test/"}],"tags":[{"name":"test","slug":"test","permalink":"http://crywolfx.github.io/tags/test/"}],"keywords":[{"name":"test","slug":"test","permalink":"http://crywolfx.github.io/categories/test/"}]},{"title":"v2ray","slug":"v2ray","date":"2019-10-21T10:31:31.000Z","updated":"2022-07-26T06:32:02.318Z","comments":true,"path":"2019/10/21/v2ray/","link":"","permalink":"http://crywolfx.github.io/2019/10/21/v2ray/","excerpt":"","text":"v2ray 配置记录v2ray + nginx + tlsv2ray安装 v2ray新手搭建使用教程 安装curl和vim RedHat系列：Redhat、Centos、Fedora等 yum install curl vim -y Debian系列：Debian、Ubuntu等 apt-get install curl vim -y v2ray脚本安装&lt;(curl -L -s https://install.direct/go.sh) v2ray命令执行 启动：systemctl start v2ray 检测：systemctl status v2ray 失败尝试：service v2ray start service v2ray status 关闭防火墙 如果有重要资料请开启对应端口 1234567systemctl stop firewalldsystemctl disable firewalld servcie iptables stopchkconfig iptables off ufw disable bbr安装 谷歌BBR google cloud vm不需要安装，默认就包含bbr 安装wget centos yum install wget -y debian apt-get install wget -y 安装bbrwget --no-check-certificate https://github.com/sprov065/blog/raw/master/bbr.sh &amp;&amp; bash bbr.sh 秋水逸冰版本wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh &amp;&amp; chmod +x bbr.sh &amp;&amp; ./bbr.sh 检测是否安装成功lsmod | grep bbr 域名配置 域名解析 申请ssl证书 上传ssl证书至vps 配置v2ray ui面板配置v2-ui 自定义json配置v2ray配置 访问: http://example.com:65432 打开面板 nginx安装 debian9 安装nginx12sudo apt update sudo apt install nginx nginx命令 启动: systemctl start nginx 停止: systemctl stop nginx 重启: systemctl restart nginx 热重载: systemctl reload nginx 开机自启动: systemctl enable nginx 开机不自启动: systemctl disable nginx 配置configvi /etc/nginx/sites-available/example.com 反向代理 server&#123; listen 80; server_name example.com; return 301 https://$server_name$request_uri; #http重定向至https &#125; server &#123; listen 443 ssl http2 default_server; listen [::]:443 ssl http2 default_server; server_name example.com www.example.com; ssl_certificate /etc/nginx/ssl/example.com.crt; #ssl证书 ssl_certificate_key /etc/nginx/ssl/example.com.key; #ssl证书 root /var/www/html; #根目录 index index.html index.htm index.nginx-debian.html index.php; location /ray &#123; #客户端配置需要和此目录保持一致 proxy_redirect off; proxy_pass http://127.0.0.1:4443; #端口需要和v2ray配置的端口一致 proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection &quot;upgrade&quot;; proxy_set_header Host $http_host; &#125; &#125; 执行nginx -t检测配置是否正确 sudo ln -s /etc/nginx/sites-available/example.com /etc/nginx/sites-enabled/ 将该nginx配置文件软链到sites-enabled目录下 执行systemctl reload nginx使得配置生效 配置根目录伪装网站客户端 windows mac android ios(i2ray、Shadowrocket、Kitsunebi) test","categories":[],"tags":[{"name":"科学上网","slug":"科学上网","permalink":"http://crywolfx.github.io/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"}],"keywords":[]},{"title":"ssr","slug":"ss","date":"2019-10-21T10:31:31.000Z","updated":"2022-07-26T06:26:20.358Z","comments":true,"path":"2019/10/21/ss/","link":"","permalink":"http://crywolfx.github.io/2019/10/21/ss/","excerpt":"","text":"ssr 配置记录锐速wget -N --no-check-certificate https://raw.githubusercontent.com/crywolfx/science-ss/master/ss/serverspeeder.sh &amp;&amp; chmod +x serverspeeder.sh &amp;&amp; bash serverspeeder.sh bbrwget -N --no-check-certificate https://raw.githubusercontent.com/crywolfx/science-ss/master/ss/bbr.sh &amp;&amp; &amp;&amp; chmod +x bbr.sh &amp;&amp; bash bbr.sh bbr魔改wget -N --no-check-certificate https://raw.githubusercontent.com/crywolfx/science-ss/master/ss/bbr_diy.sh &amp;&amp; &amp;&amp; chmod +x bbr_diy.sh &amp;&amp; bash bbr_diy.sh 多合一wget -N --no-check-certificate https://raw.githubusercontent.com/crywolfx/science-ss/master/ss/all.sh &amp;&amp; &amp;&amp; chmod +x all.sh &amp;&amp; bash all.sh ssrwget –no-check-certificate https://raw.githubusercontent.com/crywolfx/science-ss/master/ss/shadowsocksR.sh &amp;&amp; chmod +x shadowsocksR.sh &amp;&amp; ./shadowsocksR.sh 2&gt;&amp;1 | tee shadowsocksR.log","categories":[],"tags":[{"name":"科学上网","slug":"科学上网","permalink":"http://crywolfx.github.io/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"}],"keywords":[]},{"title":"js基础总结","slug":"基础总结","date":"2019-07-26T02:54:53.000Z","updated":"2022-07-26T06:26:20.358Z","comments":true,"path":"2019/07/26/基础总结/","link":"","permalink":"http://crywolfx.github.io/2019/07/26/%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/","excerpt":"","text":"前端基础总结执行上下文&#x2F;作用域链&#x2F;闭包 1. 执行上下文 JavaScript 中有三种执行上下文类型。 全局执行上下文 — 这是默认或者说基础的上下文，任何不在函数内部的代码都在全局上下文中。它会执行两件事：创建一个全局的 window 对象（浏览器的情况下），并且设置 this 的值等于这个全局对象。一个程序中只会有一个全局执行上下文。 函数执行上下文 — 每当一个函数被调用时, 都会为该函数创建一个新的上下文。每个函数都有它自己的执行上下文，不过是在函数被调用时创建的。函数上下文可以有任意多个。每当一个新的执行上下文被创建，它会按定义的顺序（将在后文讨论）执行一系列步骤。 Eval 函数执行上下文 — 执行在 eval 函数内部的代码也会有它属于自己的执行上下文，但由于 JavaScript 开发者并不经常使用 eval，所以在这里我不会讨论它。 创建执行上下文 分为两个阶段：创建阶段和执行阶段 创建阶段包含 this 值的决定，即我们所熟知的 This 绑定。 作用域链(Scope chain)&#x2F; 创建词法环境组件。 变量对象(Variable object，VO) &#x2F; 创建变量环境组件。 在全局执行上下文中，this 的值指向全局对象。(在浏览器中，this引用 Window 对象)。 在函数执行上下文中，this 的值取决于该函数是如何被调用的。如果它被一个引用对象调用，那么 this 会被设置成那个对象，否则 this 的值被设置为全局对象或者 undefined（在严格模式下）。例如： 12345678910111213let foo = &#123; baz: function() &#123; console.log(this); &#125;&#125;foo.baz(); // &#x27;this&#x27; 引用 &#x27;foo&#x27;, 因为 &#x27;baz&#x27; 被 // 对象 &#x27;foo&#x27; 调用let bar = foo.baz;bar(); // &#x27;this&#x27; 指向全局 window 对象，因为 // 没有指定引用对象 遇到函数执行的时候，就会创建一个执行上下文 2作用域JavaScript 采用的是词法作用域（静态作用域），函数的作用域在函数定义的时候就决定了。 函数提升是整个代码块提升到它所在的作用域的最开始执行 123456789101112131415161718foo(); //1 var foo; function foo () &#123; console.log(1);&#125; foo = function () &#123; console.log(2);&#125;foo();/* result12*/ 进入执行上下文时，首先会处理函数声明，其次会处理变量声明，如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性。 12345678910console.log(foo);function foo()&#123; console.log(&quot;foo&quot;);&#125;var foo = 1;/*[Function: foo]*/ 3. this&#x2F;call&#x2F;apply&#x2F;bindthis简单理解:一般指调用的对象，从ECMAScript角度理解较为复杂。 ECMAScript 的类型分为语言类型和规范类型。 语言类型 是开发者直接使用 ECMAScript 可以操作的。其实就是我们常说的Undefined, Null, Boolean, String, Number, 和 Object。 call12345678910111213141516171819202122232425262728293031323334353637383940// call实现// es5Function.prototype._callEs5 = function (context) &#123; context = context !== undefined &amp;&amp; context !== null ? context : (typeof window !== undefined ? window : global); context.__fn__ = this; var args = []; for (var i = 1; i &lt; arguments.length; i ++) &#123; args.push(&#x27;arguments[&#x27;+ i +&#x27;]&#x27;); &#125; var result = eval(&#x27;context.__fn__(&#x27; + args +&#x27;)&#x27;); delete context.__fn__; return result;&#125;// es6Function.prototype._callEs6 = function (context, ...args) &#123; context = context !== undefined &amp;&amp; context !== null ? context : (typeof window !== &#x27;undefined&#x27; ? window : global); const key = Symbol(&#x27;key&#x27;); context[key] = this; const result = context[key](...args); delete context[key]; return result;&#125;function a (name, age) &#123; console.log(this.value, name, age); return this.type;&#125;var b = &#123; value: &#x27;b-name&#x27;, type: &#x27;type-b&#x27;&#125;value = &#x27;global-value&#x27;;type = &#x27;global-type&#x27;console.log(&#x27;_callEs5&#x27;, a._callEs5(b, &#x27;zs&#x27;, &#x27;13&#x27;));console.log(&#x27;_callEs6&#x27;, a._callEs6(null, &#x27;zs&#x27;, &#x27;13&#x27;));console.log(&#x27;call&#x27;, a.call(null, &#x27;zs&#x27;, &#x27;13&#x27;)); apply12345678910111213141516171819202122232425262728293031323334353637383940// apply// es5Function.prototype._applyEs5 = function (context) &#123; context = context !== undefined &amp;&amp; context !== null ? context : (typeof window !== undefined ? window : global); context.__fn__ = this; var params = arguments[1] || []; var args = []; for (var i = 0; i &lt; params.length; i++) &#123; args.push(&#x27;params[&#x27;+ i +&#x27;]&#x27;); &#125; var result = eval(&#x27;context.__fn__(&#x27; + args +&#x27;)&#x27;); delete context.__fn__; return result;&#125;// es6Function.prototype._applyEs6 = function (context, args) &#123; context = context !== undefined &amp;&amp; context !== null ? context : (typeof window !== &#x27;undefined&#x27; ? window : global); const key = Symbol(&#x27;key&#x27;); context[key] = this; const result = context[key](...args); delete context[key]; return result;&#125;function c (name, age) &#123; console.log(this.value, name, age); return this.type;&#125;var d = &#123; value: &#x27;b-name&#x27;, type: &#x27;type-b&#x27;&#125;value = &#x27;global-value&#x27;;type = &#x27;global-type&#x27;console.log(&#x27;_applyEs5&#x27;, c._applyEs5(d, [&#x27;zs&#x27;, &#x27;13&#x27;]));console.log(&#x27;_applyEs6&#x27;, c._applyEs6(null, [&#x27;zs&#x27;, &#x27;13&#x27;]));console.log(&#x27;apply&#x27;, c.apply(null, [&#x27;zs&#x27;, &#x27;13&#x27;])); call和apply作用上把原函数给调用的对象使用，并且把this指向调用的对象。 如果原函数是构造函数，其构造属性也会挂载到参数对象上。 12345678function A () &#123; this.name = &#x27;123&#x27;; var c = &#x27;345&#x27;&#125;var c = &#123;&#125;;A.call(c)console.log(c); // &#123; name: &#x27;123&#x27; &#125;, 如果原c上有name这个属性。会被覆盖 实际模拟实现：把函数隐示的挂载到传的参数对象上，执行完毕后删除挂载的函数。 bind1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// bindFunction.prototype._bindEs5 = function (context) &#123; var _this = this; var preArgs = Array.prototype.slice.call(arguments, 1) || []; var fNOP = function () &#123;&#125;; var Fuc = function () &#123; var agrs = preArgs.concat(Array.prototype.slice.call(arguments)); return _this.apply(this instanceof Fuc ? this : context, agrs) &#125; fNOP.prototype = this.prototype; Fuc.prototype = new fNOP(); return Fuc;&#125;Function.prototype._bindEs6 = function (context, ...agrs) &#123; const _this = this; const Fn = function (agrs2) &#123; return _this.apply(this instanceof Fn ? this : context, [...agrs, ...agrs2]); &#125; Fn.prototype = Object.assign(this.prototype); return Fn;&#125;var value = 2;var foo = &#123; value: 1&#125;;function bar(name, age) &#123; this.habit = &#x27;shopping&#x27;; this.bar = &#x27;bar&#x27;; console.log(this.value); // undefined 之所以返回undefined是因为 后面实例化改变了this的指向，指向了当前对象 console.log(this.bar); // bar console.log(name); // daisy console.log(age); // 18&#125;bar.prototype.friend = &#x27;kevin&#x27;;var bindFoo = bar._bindEs5(foo, &#x27;daisy&#x27;);var obj = new bindFoo(&#x27;18&#x27;);console.log(&quot;************&quot;); console.log(obj.habit); // shoppingconsole.log(obj.friend); // kevin bind在当做对象实例化的时候，this会指向当前实例化的对象。 4.原型&#x2F;继承&#x2F;new 123456var person = new Person();console.log(person.__proto__ === Person.prototype); // trueconsole.log(Person === Person.prototype.constructor); // trueconsole.log(Person === person.constructor); // true// 顺便学习一个ES5的方法,可以获得对象的原型console.log(Object.getPrototypeOf(person) === Person.prototype) // true 当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。 __proto__ 绝大部分浏览器都支持这个非标准的方法访问原型，然而它并不存在于 Person.prototype 中，实际上，它是来自于 Object.prototype ，与其说是一个属性，不如说是一个 getter&#x2F;setter，当使用 obj.__proto__ 时，可以理解成返回了 Object.getPrototypeOf(obj)。其指向了构造函数的prototype prototype 创建的每个函数都有prototype，这个属性是一个指针，指向构造函数的原型对象。 构造方法、原型方法、类方法 类方法实际上就是静态方法，不需要实例化便可以调用 构造方法需要实例化才能调用，每次实例化都会生成一份，会额外占用内存 原型方法需要实例化才能调用，每个实例化的对象都共用同一个原型链上的方法 new，实例化实现模拟实现：创建一个空实例对象，把原构造函数Constructor的原型prototype挂载到空对象的__proto__属性上，这样实例对象(obj)就可以访问到原型属性。然后通过call或者apply修改this的指向到新建的对象，这样实例对象(obj)就可以访问到构造属性。 1234567891011121314151617181920function objectFactoryEs5() &#123; // 实例化空对象 var obj = new Object(), // 构造函数 Constructor = Array.prototype.shift.call(arguments); // 复制原型方法 obj.__proto__ = Constructor.prototype; // 新的this全部指向 obj，并且把之前的参数传递过来 var ret = Constructor.apply(obj, arguments); return typeof ret === &#x27;object&#x27; ? ret || obj : obj;&#125;;function objectFactoryEs6(Constructor, ...args) &#123; const obj = new Object(); obj.__proto__ = Constructor.prototype; const ret = Constructor.call(obj, ...args); return typeof ret === &#x27;object&#x27; ? ret || obj : obj;&#125;; 继承组合继承1234567891011121314151617181920212223// 组合继承function Person (name, age) &#123; console.log(&quot;new Person&quot;); this.name = name; this.age = age; this.test = &#x27;123&#x27;;&#125;Person.prototype.eat = function (food) &#123; console.log(this.name + &#x27; is eating &#x27; + food); console.log(this.test);&#125;function Child (name, age, study) &#123; Person.call(this, name, age); this.study = study;&#125;// 这一步会实例化一遍 PersonChild.prototype = new Person();Child.prototype.constructor = Child;// 这一步还会实例化一遍 Person，因为内部为了继承Person的构造属性，用了call进行调用var a = new Child(&#x27;zz&#x27;,&#x27;18&#x27;); 组合继承优化123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 复合继承优化，解决实例化两边父类的问题function Person (name, age) &#123; this.name = name; this.age = age; this.test = &#x27;eat 测试输出代码&#x27;;&#125;Person.prototype.eat = function (food) &#123; console.log(this.name + &#x27; 在吃 &#x27; + food); console.log(this.test);&#125;function Child (name, age, study) &#123; Person.call(this, name, age); this.study = study;&#125;function Child2 (name, age) &#123; Person.call(this, name, age);&#125;function extendsPrototype (Child, Parent) &#123; // 方案① // var Fun = function () &#123; console.log(&quot;new Fun &quot;)&#125;; // Fun.prototype = Parent.prototype; // Child.prototype = new Fun(); // 方案② Child.prototype = Object.create(Parent.prototype); // 如果直接写 Child.prototype = Parent.prototype;的话，原型上的所有方法都会被子类重写。 Child.prototype.constructor = Child; return Child;&#125;// 这一步会实例化一遍 PersonChild = extendsPrototype(Child, Person);Child2 = extendsPrototype(Child2, Person);Child2.prototype.eat = function () &#123; console.log(&quot;eat 方法 被&quot; + this.name +&quot;重写&quot;);&#125;;var a = new Child(&#x27;张三&#x27;,&#x27;18&#x27;);var b = new Child2(&#x27;李四&#x27;, &#x27;19&#x27;);var c = new Person(&#x27;父亲&#x27;,&#x27;45&#x27;);a.eat(&#x27;汉堡&#x27;); // 张三 在吃 汉堡b.eat(); // eat 方法 被李四重写c.eat(&#x27;肉&#x27;); // 父亲 在吃 肉console.log(Child.prototype.constructor); // Child console.log(a.__proto__.__proto__ === Child.prototype.__proto__); // trueconsole.log(Child.prototype.__proto__ === Person.prototype); // true 5. Promise6. 深浅拷贝7. 事件机制&#x2F;Event Loop8. 闭包 概念 即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回） 在代码中引用了自由变量 常见函数 123456789101112function a () &#123; var c = 1; return function () &#123; c++; console.log(c) return c; &#125;&#125;var b = a();b(); // 2b(); // 3 12345678910111213141516171819202122232425262728293031323334353637383940414243var data = [];for (var i = 0; i &lt; 3; i++) &#123; data[i] = function () &#123; console.log(i); &#125;;&#125;data[0](); // 3data[1](); // 3data[2](); // 3 // 在执行data[0]()的时候，上方的for循环已经结束了，i已经都是3，data[0]()的作用链域在全局。var没有局部作用域，所以会获取到3。// 闭包修改var data = [];for (var i = 0; i &lt; 3; i++) &#123; data[i] = (function (i) &#123; return function () &#123; console.log(i); &#125;; &#125;)(i)&#125;data[0](); // 1data[1](); // 2data[2](); // 3 // babel做的操作var data = [];var _loop_1 = function (i) &#123; data[i] = function () &#123; console.log(i); &#125;;&#125;;for (var i = 0; i &lt; 3; i++) &#123; _loop_1(i);&#125;data[0](); // 0data[1](); // 1data[2](); // 2// 实际上是生成一个块级作用域，传递了出去。 9.按值传递在一个函数进行调用的时候，传递的参数是按照值进行传递的。对于基本类型，把值直接传了进去。但是对于引用类型，传递的实际上是地址。如果在函数中修改了引用类型的某个属性，就会把这个地址所对应的值修改。如果在函数中直接把这个引用类型的值完全都修改了。就是重新拷贝赋了一个新值，不会对原值产生影响。 123456789101112131415161718192021222324252627282930// 1var value = 1;function foo(v) &#123; v = 2; console.log(v); //2&#125;foo(value);console.log(value) // 1// 2var obj = &#123; value: 1&#125;;function foo(o) &#123; o.value = 2; console.log(o.value); //2&#125;foo(obj);console.log(obj.value) // 2// 3var obj = &#123; value: 1&#125;;function foo(o) &#123; o = 2; console.log(o); //2&#125;foo(obj);console.log(obj.value) // 1 10. 浮点数精度问题 该问题不是ECMAScript独有的问题，ECMAScript使用的是IEEE754标准，浮点数，采用双精度，用64位字节来储存一个浮点数。 转化为二进制的时候计算的时候 导致了精度丢失，所以0.1 + 0.2 !&#x3D; 0.3 具体查看 其他foo instanceof Foo在语言内部，实际调用的是Foo[Symbol.hasInstance](foo) 123let obj = new Foo(...args)let obj = Reflect.construct(Foo, args)// 以上两个式子是等价的","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://crywolfx.github.io/tags/js/"}],"keywords":[]},{"title":"js基础方法","slug":"方法","date":"2019-07-26T02:54:53.000Z","updated":"2022-07-26T06:26:20.358Z","comments":true,"path":"2019/07/26/方法/","link":"","permalink":"http://crywolfx.github.io/2019/07/26/%E6%96%B9%E6%B3%95/","excerpt":"","text":"js基础方法洗牌算法123456789101112function shuffle(arr) &#123; const shuffled = [...arr]; const len = arr.length; for (let i = len - 1; i &gt; 0; i--) &#123; const j = Math.floor((i + 1) * Math.random()); const temp = shuffled[i]; shuffled[i] = shuffled[j]; shuffled[j] = temp; &#125; return shuffled;&#125; 随机抽取（洗牌算法延伸）12345678910111213141516funciton getRandomArrayElements(arr, count) &#123; const shuffled = [...arr]; const len = arr.length; if (len &lt; count) &#123; count = len; &#125; const min = len - count; for (let i = len - 1; i &gt;= min; i--) &#123; const j = Math.floor((i + 1) * Math.random()); const temp = shuffled[i]; shuffled[i] = shuffled[j]; shuffled[j] = temp; &#125; return shuffled.slice(min);&#125; 节流12345678910111213141516function throttle(func, delay) &#123; let timer = null; let startTime = Date.now(); return function () &#123; const curTime = Date.now(); // 剩余时间 const remaining = delay - (curTime - startTime); // console.log(remaining); const context = this; const args = arguments; if (remaining &lt;= 0) &#123; func.apply(context, args); startTime = Date.now(); &#125; &#125;&#125; 防抖1234567function debounce(func, delay) &#123; let timeout = null; return function() &#123; timeout &amp;&amp; clearTimeout(timeout); timeout = setTimeout(func, delay); &#125;&#125;","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://crywolfx.github.io/tags/js/"}],"keywords":[]}]}